#!/usr/bin/python3
#To Run:
#Install scapy: $sudo pip install scapy
#Run Proxy Sniffer $sudo python3 <filename.py>
#Must run from sudo for packet processing privileges.
from netfilterqueue import NetfilterQueue
from scapy.all import *
import socket
import time
from Classes.Account import Account
from Utils.Utils import *
from ipaddress import IPv4Address
import os, sys
import codecs
import copy

load_contrib('bgp') #scapy does not automatically load items from Contrib. Must call function and module name to load.

#####Synchronizes ASN with blockchain account data##################
tx_sender_name = "ACCOUNT"+str(sys.argv[1]) #must add an asn # after account, eg. ACCOUNT151 we do this programmatically later in program
tx_sender = Account(AccountType.TransactionSender, tx_sender_name)
#print(tx_sender)
tx_sender.load_account_keys()
tx_sender.generate_transaction_object("IANA", "CONTRACT_ADDRESS")
print("Transaction setup complete for: " + tx_sender_name)

################Establishes local IPTABLES Rule to begin processing packets############
QUEUE_NUM = 1
# insert the iptables FORWARD rule
os.system("iptables -I INPUT -p tcp --dport 179 -j NFQUEUE --queue-num {}".format(QUEUE_NUM))
os.system("iptables -I INPUT -p tcp --sport 179 -j NFQUEUE --queue-num {}".format(QUEUE_NUM))
os.system("iptables -I OUTPUT -p tcp --dport 179 -j NFQUEUE --queue-num {}".format(QUEUE_NUM))
os.system("iptables -I OUTPUT -p tcp --sport 179 -j NFQUEUE --queue-num {}".format(QUEUE_NUM))
#Check whether packet is inbound from external location or generated by local router
#def pkt_check(packet):
   # hw=packet.get_hw()
   # print(str(hw))
   # print(str(Ether().src))
   # pkt = IP(packet.get_payload())
   # print(str(pkt.summary()))
   # if pkt[Ether].src != Ether().src:
       # print("Packet inbound on interface: "+ pkt.sniffed_on)
       # incoming(pkt)
   # else:
       # print("Packet outbound on interface: "+ pkt.sniffed_on)
       # outgoing(pkt)
       
def main(packet):
    print('checking packet')
    pkt = IP(packet.get_payload())
    print(pkt.summary())
    print('checking for bgp header')
    if (str(pkt.summary()).find('BGPHeader') > 0) and (pkt[BGPHeader].type == 2) :
        orig_len=pkt[IP].len
        #pkt2=copy.deepcopy(pkt)
        #cmd_lst_1=scapy_command_builder(pkt2,"pkt2")
        cmd_lst_2=scapy_command_builder(pkt,"pkt")
        #print(cmd_lst_1)
        #print(cmd_lst_2)
        #header=packet_header(cmd_lst_2,pkt)
        bgp_update_checker(cmd_lst_2,pkt)
        #return header,payload
        #pkt_final2=pkt_assembler(header,payload)
        pkt_final=packet_prepper(pkt)
        pkt.show2()
        #new_len=pkt_final[IP].len
        print ('Original packet length: '+str(orig_len) + ' New packet length: ' +str(pkt_final[IP].len))
        packet.accept() # or would it be pkt.accept()?
    else:
        packet.accept()
        
def pkt_assembler(header,payload):
    print('assembling packet')
    pkt_assem='header[0]/header[1]/header[2]'
    for num in range(len(payload)):
        pkt_assem+='/payload['+str(num)+']'
    final_pkt=eval(pkt_assem)
    return final_pkt
    


def scapy_command_builder(pkt,tmp_str):
    print('building commands')
    x=pkt.summary().split(' / ')
    x[1]='TCP'
    x=expander(x,tmp_str)
    print ('commands are')
    print (x)
    return x
    
def expander(lst,tmp_str):
     print('expanding commands')
     w=''
     s=[]
     for item in lst[:]:
         w+='[ ' + str(item) + ' ]'
         s.append(tmp_str+'['+w[1:-1]+']')
     return s
    
def packet_header(header_cmd,pkt2):
     print('packet header')
     del header_cmd[3:]
     header=[]
     for n in range(0,3):
         eval(header_cmd[-1-n]).remove_payload()
         header.append(eval(header_cmd[-1-n]))
     header.reverse()
     return header
     
def packet_prepper(pkt):
   print('packet prepper')
   pkt[IP].len
   #pkt.show()
   del pkt[IP].chksum
   del pkt[TCP].chksum
   return pkt
   
 
def bgp_update_checker(cmd_lst,pkt):
     print('checking packet')
     del cmd_lst[:3]
     #print (cmd_lst)
     print(" Break ============")
     pkt_placeholder=[]
     for n in range(len(cmd_lst)):
         print('testing ...' + str(cmd_lst[(-1-n)]))
         if  str(cmd_lst[(-1-n)]).endswith('[ BGPUpdate ]'):
             nlri_asn_check(str(cmd_lst[(-1-n)]), pkt)
             #pkt_placeholder.append(segment)
             #eval(cmd_lst[(-1-n)]).remove_payload()

         else:
            pass
             #eval(cmd_lst[(-1-n)]).remove_payload()
             #pkt_placeholder.append(eval(cmd_lst[(-1-n)]))
             #eval(cmd_lst[(-1-n)]).remove_payload()

     #pkt_placeholder.reverse()
     #return pkt_placeholder

def nlri_asn_check(cmd, pkt):
    print('conducting NLRI check....')
    print('checking: '+cmd)
    print('trying ASN Identification...')
    print ('route withdrawl check: ' + str(eval(cmd).route_withdrawl_len)
    if eval(cmd).withdrawn_routes_len == 0:
        print(str(eval(cmd).path_attr[1].attribute.segments[-1].segment_value))
        print('entering if statement')
        if len(eval(cmd).path_attr[1].attribute.segments[-1].segment_value) > 1:
           asn=eval(cmd).path_attr[1].attribute.segments[-1].segment_value[-1]
        else:
           print('reverting to segment length')
           asn=eval(cmd).path_attr[1].attribute.segments[-1].segment_length
        #nlri_lst=copy.deepcopy(eval(cmd).nlri) 
        print('ASN is: '+str(asn) + ' Checking prefixes:....')
        for num in range(len(eval(cmd).nlri)):  
            segment=[asn, eval(cmd).nlri[num].prefix.split('/')[0], eval(cmd).nlri[num].prefix.split('/')[1], "Internal"]   
            check=bgpchain_validate(segment, tx_sender)                  
            #print ('Placeholder evaluation check for: ' + str(adv_segment[0]) + ' ' + str(adv_segment[1]) +' ' +str(adv_segment[2])) ###replace with blockchain validation code.
            #check='Authorized'
            if check =='Authorized':
               pass
            else:
                eval(cmd).nlri[num].pop()
        #eval(cmd).nlri=nlri_lst
        #return eval(cmd)
    else:
        print('Segment was a route withdrawl')
        return
        #return eval(cmd)



def bgpchain_validate(segment, tx_sender):
    print ("Validating segment.....")
    print (tx_sender)
    inIP = IPv4Address(segment[1])
    print (inIP)
    inSubnet = int(segment[2])
    print (str(inSubnet))
    inASN = int(segment[0])
    print (str(inASN))
    #print(type(inASN), inASN)
    #print("tes")
    # Validate the prefix<=>ASN mapping. Returns an enum.
    #print ("testing tx_sender: "+str(tx_sender))
    print ("Checking segment: AS" + str(inASN)+ " , " + str(inIP) + "/" + str(inSubnet))
    validationResult = tx_sender.tx.sc_validatePrefix(int(inIP), inSubnet, inASN)
    print(str(validationResult))
    if validationResult==validatePrefixResult.prefixValid:
        print("Segment Validated.")
        return "Authorized"
    else:
        print("Segment Validation Failed. Error: " + str(validationResult))
        return False
        

if __name__=='__main__':

# instantiate the netfilter queue
   nfqueue = NetfilterQueue()
 
   try:
      nfqueue.bind(1, main)
       #nfqueue.bind(2, pkt_in)
      nfqueue.run()
   except KeyboardInterrupt:
      print('')
      # remove that rule we just inserted, going back to normal.
      os.system("iptables --flush")
      nfqueue.unbind()
