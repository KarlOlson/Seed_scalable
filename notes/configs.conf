#This is config for AS150 Router:


protocol bgp p_rs100 {
    ipv4 {
        table t_bgp;
        import filter {
            bgp_large_community.add(PEER_COMM); #This line I think defines to establish peering with the community participating in the route server on the IX.
            bgp_local_pref = 20;
            accept;
        };
        export where bgp_large_community ~ [LOCAL_COMM, CUSTOMER_COMM];
        next hop self;
    };
    local 10.100.0.150 as 150;
    neighbor 10.100.0.100 as 100; #this is the peering of 150→ix 100, but it knows via the large community peering that it should learn what participants are avail on IX100 and peer with the other clients who are participating.
}

# For IX100:
protocol bgp p_as150 {
    ipv4 {
        import all;
        export all;
    };
    rs client; #establishes the remote bgp router as a client of the route server
    local 10.100.0.100 as 100;
    neighbor 10.100.0.150 as 150;
}
protocol bgp p_as151 {
    ipv4 {
        import all;
        export all;
    };
    rs client;
    local 10.100.0.100 as 100;
    neighbor 10.100.0.151 as 151;
}
protocol bgp p_as152 {
    ipv4 {
        import all;
        export all;
    };
    rs client;
    local 10.100.0.100 as 100;
    neighbor 10.100.0.152 as 152;
}

#so based on these two configs I see the process working like this
1. On setup, proxy checks local host config for peering relationships.
a. First conduct a search for “protocol bgp” statement to locate the running bgp neighbor processes.
b. if “protocol bgp” statement contains “bgp_large_community” then find next neighbor statement to locate route server address:
1. use route server address to locate smart contract for route server and associated peering relationships (would have to create new contract to do this)
2. For each “neighbor” in route server smart contract, execute a smart contract to record neighbor relationship between establishing host and each client present in the route server contract.
c if “protocol bgp” statement does not contain “bgp_large_community” then use next neighbor statement to identify neighbor peering and record relationship to smart contract.
d. check if any more “protocol bgp” statements remain and repeat
2. sleep 60, check again for updates